<html>
  <head>
    <&HTML-AND-JAVASCRIPT(.css)>
    <title>Double TAP - Text and Test Anything Protocol</title>
  </head>
  <body>
    <&HTML-AND-JAVASCRIPT(.navbar)>
    <section class="hero">
      <div class="hero-body">
        <p class="title">Hello Double TAP</p>
        <p class="subtitle">Text and Test Anything Protocol</p>
        <p class="control">
          Double TAP is lightweight testing framework where users write black box tests as rules
          checking output from tested "boxes". Boxes could be anything from http client, web server
          to messages in syslog. This universal approach allows to test anything with just dropping
          text rules describing system behavior in black box manner.
        </p>
        <p class="control">
          <br>
          Following a simple example for http web server. <hr>Check rule code:
          <pre>
HTTP/1.1 200 OK
Server: gunicorn/19.9.0</pre>
          Implementation code aka box (the one producing output):
          <pre><code class="language-bash">curl http://httpbin.org -D - -s -o /deb/null | head</code></pre>
          Test report:
          <pre>[task stdout]
22:39:23 :: HTTP/1.1 200 OK
22:39:23 :: Date: Wed, 31 Dec 2025 19:39:23 GMT
22:39:23 :: Content-Type: text/html; charset=utf-8
22:39:23 :: Content-Length: 9593
22:39:23 :: Connection: keep-alive
22:39:23 :: Server: gunicorn/19.9.0
[task check]
stdout match &lt;HTTP/1.1 200 OK&gt; True
stdout match &lt;Server: gunicorn/19.9.0&gt; True</pre>
          <hr>
          Imaging we have saved the previous check into file and uploaded it
          to some server (performing checks) under name web-server-ok, now
          we can run the check using API call:
          <pre><code class="language-bash">curl http://httpbin.org -D - -s -o /deb/null | head | dtap --box - --check web-server-ok --params fashion=gunicorn</code></pre>
          API reply:
          <pre><code class="language-json">{
  "status": "OK",
  "report": " ... "
}</code></pre>
        </p>
        <p class="control">
    <hr>
    Boxes could be predefined, allow to reuse implementations for some standard cases like checking if packages are installed, services are enabled and web servers work correctly, etc. 
    <br>
    The previous example could be rewritten in equivalent form:
          <pre><code class="language-bash">dtap --box web-server --check web-server-ok --params site=http://httpbin.org,fashion=gunicorn</code></pre>
        </p>
        <p class="control">
    <hr>
    Check some <a href="/examples">examples</a> here.
    Or read <a href="https://git.resf.org/testing/sparrow_task_check_crash_course">quick start</a> of double TAP rules language.
        </p>
        <hr>
        <p class="title">Protocol features</p>
        <ul>
          <li>            
            <span class="tag is-black">Decoupled tests</span> 
            <hr>
            Write once, use for many boxes. Tests define "interface", which 
            could be implemented in many ways on many tested boxes. For example if write test 
            for package installation like this:
            <pre>Status: install ok installed</pre>
            <br>
            The implementation logic could be verified for many Linux distributions.
            <br><br>
            Debian/Ubuntu:
            <pre><code class="language-bash">dpkg  -s nano # stdout - Status: install ok installed</code></pre>
            <br>
            Rocky Linux:
            <pre><code class="language-bash">rpm -q  nano && echo "Status: install ok installed"</code></pre>
          </li>
          <li>
            <br>            
            <span class="tag is-black">Predefined boxes</span>
            <hr>
            Predefined boxes come as a part of dtap cli distribution. No need to 
            implement tests for some typical cases, just use them with
            --box parameter and overriding box input settings via --params.
            <hr>
             For custom boxes just redirect output for verification via --box - 

          </li>
          <li>
            <br>            
            <span class="tag is-black">Community driven tests</span>
            <hr> 
            With time the more people involved the more boxes and check rules are available for public consumption.
            Tests are no longer embedded into hidden implementation, test driven development encourages
            other participants to implement software that passes tests, not software including tests
          </li>
           <li>
            <br>            
            <span class="tag is-black">TDD/BDD embedded</span>
            <hr> 
            Check rules are blueprint, rough specification of system behavior. So we not just write test,
            we describe the system before it's even implemented. Think cucumber tool but with focus on messages.
            <hr>
            To list all available checks:
            <pre><code class="language-bash">dtap  --check_list</code></pre>
          </li>
          <li>
            <br>            
            <span class="tag is-black">Why it's called Double TAP</span>
            <hr> 
            TAP is well known and mature protocol that is widely used in unit testing.
            The pun is to add "texting" to "testing", so we end up double T or Double TAP protocol.
            Here is the association ends. Double TAP differs from TAP, being more generic and black box testing framework. Texting means tests are based on the idea of verifying
            system behavior by checking produced text messages against set of rules.
          </li>
        </ul>
      </div>
</body>
</html>
